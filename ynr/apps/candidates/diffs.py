# The functions in this file are to help produce human readable diffs
# between our JSON representation of candidates.


import json
import re

import jsonpatch
import jsonpointer
from dateutil.parser import parse
from django.http import Http404
from django.utils.timezone import now, make_aware

from candidates.models import Ballot
from candidates.models.versions import get_versions_parent_map
from elections.models import Election


def get_descriptive_value(operation, ballot_paper_id, attribute, value, leaf):
    """Get a sentence fragment describing someone's status for a ballot

    'attribute' is either "standing_in" or "party_membership", 'election'
    is one of the slugs from the elections table, and 'value' is what would
    be under that year in the 'standing_in' or 'party_memberships'
    dictionary (see the comment at the top of update.py)."""

    try:
        date = make_aware(parse(ballot_paper_id[-10:]))
        future_ballot = date > now()
    except ValueError:
        # The ballot slug may have changed since the diff was stored.
        # Assume this is an older ballot
        future_ballot = False

    if attribute == "candidacies":
        message = value
        if leaf:
            if leaf == "party_list_position":
                message = "Set list position to '{value}'"
            if leaf == "elected":
                if value:
                    message = "Marked as elected"
                else:
                    message = "Marked as not elected"

        else:
            if future_ballot:
                verb = "standing"
            else:
                verb = "stood"
            if value.get("party_list_position"):
                extra = " (list position: {}) ".format(
                    value["party_list_position"]
                )
            else:
                extra = ""
            message = "{verb} for {party_id} {extra}".format(
                verb=verb, party_id=value["party"], extra=extra
            ).strip()

        return message.format(
            ballot_paper_id=ballot_paper_id, value=value, party_id=value
        )


def explain_candidacy(operation, attribute, ballot_paper_id, leaf):
    """Set 'value' and 'previous_value' in operation to a readable explanation

    'attribute' is one of 'standing_in' or 'party_memberships'."""
    for key in ("previous_value", "value"):
        if key not in operation:
            continue
        if ballot_paper_id:
            operation[key] = get_descriptive_value(
                operation, ballot_paper_id, attribute, operation[key], leaf
            )
        else:
            clauses = []
            items = (operation[key] or {}).items()
            for election, value in sorted(items, reverse=True):
                clauses.append(
                    get_descriptive_value(
                        operation, election, attribute, value, leaf
                    )
                )
            operation[key] = " and ".join(clauses)


def get_version_diff(from_data, to_data):
    """Calculate the diff (a mangled JSON patch) between from_data and to_data"""

    basic_patch = jsonpatch.make_patch(from_data, to_data)
    result = []
    for operation in sorted(basic_patch, key=lambda o: (o["op"], o["path"])):
        op = operation["op"]
        attribute = operation["path"].split("/")[1]
        ignore = False

        if op in ("replace", "remove"):
            operation["previous_value"] = jsonpointer.resolve_pointer(
                from_data, operation["path"], default=None
            )

        # We deal with candidacies slightly
        # differently so they can be presented in human-readable form,
        # so match those cases first:
        if operation["path"].strip("/").startswith("candidacies/"):
            parts = operation["path"].split("/")[1:]
            attribute, ballot_paper_id, *leaf = parts
            if leaf:
                leaf = leaf[0]
            else:
                leaf = None
            explain_candidacy(operation, attribute, ballot_paper_id, leaf)

        if op in ("replace", "remove", "move"):
            if op == "replace" and not operation["previous_value"]:
                if operation["value"]:
                    operation["op"] = "add"
                else:
                    # Ignore replacing no data with no data:
                    ignore = True
        elif op == "add":
            # It's important that we don't skip the case where a
            # standing_in value is being set to None, because that's
            # saying 'we *know* they're not standing then'
            if (not operation["value"]) and (attribute != "standing_in"):
                ignore = True
        operation["path"] = re.sub(r"^/", "", operation["path"])
        if not ignore:
            result.append(operation)
        # The operations generated by jsonpatch are incremental, so we
        # need to apply each before going on to parse the next:
        operation["path"] = "/" + operation["path"]
        from_data = jsonpatch.apply_patch(from_data, [operation])
    for operation in result:
        operation["path"] = operation["path"].lstrip("/")
    return result


def clean_version_data(data):
    data = data.copy()
    for election_slug, standing_in in data.get("standing_in", {}).items():
        if standing_in:
            standing_in.pop("mapit_url", None)
    # We're not interested in changes of these IDs:
    for i in data.get("identifiers", []):
        i.pop("id", None)

    # Remove duplicate dicts in the Identifiers
    identifiers_set = set()
    for i in data.get("identifiers", []):
        identifiers_set.add(json.dumps(i, sort_keys=True))
    # now replace the identifiers list with the unique values
    if identifiers_set:
        data["identifiers"] = [json.loads(i) for i in identifiers_set]

    for on in data.get("other_names", []):
        on.pop("id", None)
    data.pop("last_party", None)
    data.pop("proxy_image", None)
    data.pop("date_of_birth", None)
    return data


def get_parents_version_data(parents, id_to_version):
    if parents:
        return [(p, id_to_version[p]["data"]) for p in parents]
    # If there are no parents, then compare to an empty dictionary
    return [(None, {})]


def get_version_diffs(versions):
    """Add a diff to each of an array of version dicts

    The first version is the most recent; the last is the original
    version."""

    id_to_parent_ids = get_versions_parent_map(versions)
    id_to_version = {v["version_id"]: v for v in versions}
    result = []
    for v in versions:
        version_id = v["version_id"]
        v["parent_version_ids"] = id_to_parent_ids[version_id]
        version_with_diffs = v.copy()
        version_with_diffs["data"] = clean_version_data(
            version_with_diffs["data"]
        )
        version_with_diffs["parent_version_ids"] = id_to_parent_ids[version_id]
        version_with_diffs["diffs"] = [
            {
                "parent_version_id": parent_with_data[0],
                "parent_diff": get_version_diff(
                    clean_version_data(parent_with_data[1]),
                    version_with_diffs["data"],
                ),
            }
            for parent_with_data in get_parents_version_data(
                id_to_parent_ids[version_id], id_to_version
            )
        ]
        result.append(version_with_diffs)
    return result
