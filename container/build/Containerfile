from public.ecr.aws/lts/ubuntu:20.04

ARG DEBIAN_FRONTEND=noninteractive

run date \
 && apt update \
 && date

copy container/build/system-packages /tmp/apt-packages
run date \
 && </tmp/apt-packages xargs apt install --no-install-suggests --assume-yes \
 && date

run date \
 && apt-get clean \
 && rm -rf /var/lib/apt/lists/* \
 && date

# Base path for the app install build process.
arg APP_ROOT=/dc/ynr
# Path for the app's virtualenv.
arg APP_VENV=$APP_ROOT/venv
# Path for the app's code.
arg APP_CODE=$APP_ROOT/code

# Set up a virtualenv to avoid interactions with system packages, and install a
# common pre-req.
run date \
 && python -m venv $APP_VENV \
 && $APP_VENV/bin/pip install wheel \
 && date
# Use the virtualenv without explicit activation.
ENV PATH="$APP_VENV/bin:$PATH"

# Copy dependency manifests into the container image.
copy requirements.txt $APP_CODE/
copy requirements/    $APP_CODE/requirements/

# Install app requirements. Instruct pip not to use a cache directory to
# inprove container-image-level cache effectiveness.
# TODO: run as not-root?
# TODO: run upgrade pip?
run date \
 && pip install --no-cache-dir -r $APP_CODE/requirements/sopn_parsing.txt \
 && date

# Copy the client-side directory "." (i.e. the build context passed to the
# build command) into the container image.
# NB This obeys the rules in the .containerignore file.
copy . $APP_CODE/

# Set the working directory for the container entrypoint.
workdir $APP_CODE

# Invoke a lightweight, post-build test that proves the container reaches a
# baseline level of correctness, whilst also generating .pyc files for faster
# app startup.
run python manage.py check --settings=ynr.settings.testing
